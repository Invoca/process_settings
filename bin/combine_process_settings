#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'ostruct'
require 'pathname'
require 'fileutils'
require 'yaml'

PROGRAM_NAME = File.basename($PROGRAM_NAME)
SETTINGS_FOLDER = 'settings'

def end_marker(version)
  {
    'END' => {
      'version' => version
    }
  }
end

# returns a floating point version: major.minor
# where the major is the same as in the old_output_file
# and the minor is the current time_t
def default_version_number(old_output_file)
  json_doc = YAML.load_file(old_output_file)
  version = json_doc.last['END']&.[]('version') or raise "No END.version: #{json_doc.inspect}"
  major = version.to_f.truncate
  minor = Time.now.to_i
  major + minor / 10_000_000_000.0
end


def parse_options(argv)
  options = OpenStruct.new
  options.verbose = false
  option_parser = OptionParser.new(argv) do |opt|
    opt.on('-v', '--verbose', 'Verbose mode.') { options.verbose = true }
    opt.on('-r', '--root_folder=ROOT') { |o| options.root_folder = o }
    opt.on('-o', '--output=FILENAME', 'Output file.') { |o| options.output_filename = o }
    opt.on('-i', '--initial=FILENAME', 'Initial settings file for version inference.') { |o| options.initial_filename = o }
  end

  if option_parser.parse! && options.root_folder && options.output_filename && (ENV['BUILD_NUMBER'] || options.initial_filename)
    options
  else
    warn "usage: #{PROGRAM_NAME} -r staging|production -o combined_process_settings.yml [-i initial_combined_process_settings.yml] (required if BUILD_NUMBER not set)"
    option_parser.summarize(STDERR)
    exit(1)
  end
end

def read_and_combine_settings(settings_folder)
  combined_settings = []

  pushd(settings_folder) do
    Dir.glob("**/*.yml").sort.each do |settings_path|
      settings = { 'filename' => settings_path }
      settings.merge!(YAML.load_file(settings_path))

      combined_settings << settings
    end
  end

  combined_settings
end

def pushd(folder)
  pwd = FileUtils.pwd
  FileUtils.cd(folder)
  yield
ensure
  FileUtils.cd(pwd)
end

def add_warning_comment(yaml, root_folder, program_name, settings_folder)
  warning_comment = <<~EOS
  #
  # Don't edit this file directly! It was generated by #{program_name} from the files in #{root_folder.split('/').last}/#{settings_folder}/.
  #
  EOS

  yaml.sub("\n", "\n" + warning_comment)
end

#
# main
#

options = parse_options(ARGV.dup)

combined_settings = read_and_combine_settings(Pathname.new(options.root_folder) + SETTINGS_FOLDER)

# Note: version number will be an int if it came from the build number, or a float if we fell to the default
version_number = ENV['BUILD_NUMBER']&.to_i || default_version_number(options.initial_filename)
combined_settings << end_marker(version_number)

yaml = combined_settings.to_yaml
yaml_with_warning_comment = add_warning_comment(yaml, options.root_folder, PROGRAM_NAME, SETTINGS_FOLDER)

output_filename     = options.output_filename
tmp_output_filename = "#{output_filename}.tmp"

system("rm -f #{tmp_output_filename}")
File.write(tmp_output_filename, yaml_with_warning_comment)

system(<<~EOS)
  if cmp #{tmp_output_filename} #{output_filename} --silent; then
    #{"echo #{options.root_folder}: unchanged;" if options.verbose}
    rm -f #{tmp_output_filename};
  else
    #{"echo #{options.root_folder}: UPDATING;" if options.verbose}
    mv #{tmp_output_filename} #{output_filename};
  fi
EOS

exit(0)
